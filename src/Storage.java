import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;

public class Storage<T extends Comparable<T>> implements Comparable<Storage>, Serializable {
    private T data;
    public Storage[] pattern;
    private ArrayList<Storage> subpatterns;

    public Storage(T data) {
        this.data = data;
        subpatterns = null;
    }

    public Storage(Storage[] initPattern) {
        pattern = initPattern;
        subpatterns = null;
    }

    public Storage(byte[] data) {
        pattern = new Storage[data.length];
        for (int i = 0; i < data.length; i++) {
            pattern[i] = new Storage(data[i]);
        }
        subpatterns = null;
    }

    @Override
    public int compareTo(Storage o) {
        if (!isPointer() && !o.isPointer()) {
            return o.data.compareTo(data);
        } else {
            System.out.println("This should never be called for compareTo");
            return o.pattern[0].compareTo(pattern[0]);
        }
    }

    public boolean isPointer() {
        return pattern != null;
    }

    public boolean fastEquals(Storage o) {
        // safe, slower way
        if (!isPointer() && !o.isPointer()) {
            return o.data == data;
        } else {
            //System.out.println("This should never be called");
            return false;
            //return o.pattern[0].compareTo(pattern[0]);
        }

        //risky, faster(maybe?) way
       // return o.data != null && o.data == data;
    }

    public boolean fastSaferEquals(Storage o) {
        if (!isPointer() && !o.isPointer()) {
            return o.data.equals(data);
        } else {
            return false;
        }
    }

    public String toString() {
        if (isPointer()) {
            return "Pointer to " + Arrays.toString(pattern);
        } else {
            //return "Contains data: " + data;
            return String.valueOf(data);
        }
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public Storage[] getPattern() {
        return pattern;
    }

    public void setPattern(Storage[] pattern) {
        this.pattern = pattern;
    }

    //TODO: work on this!!! this is autogenerated, totally works but could use some optimization
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Storage storage = (Storage) o;
        return Objects.equals(data, storage.data) && Objects.deepEquals(pattern, storage.pattern);
    }

    @Override
    public int hashCode() {
        return Objects.hash(data, Arrays.hashCode(pattern));
    }

    public ArrayList<Storage> getSubpatterns() {
        return subpatterns;
    }

    public void setSubpatterns(ArrayList<Storage> subpatterns) {
        this.subpatterns = subpatterns;
    }

    // TODO: deprecated, remove soon or figureo ut wihat to do with
    public byte[] toByteArray() {
        byte[] toReturn = new byte[trueLength()];
        int i = 0;
        int writePos = 0;
        while (i < pattern.length) {
            Storage curr = pattern[i];
            if (curr.isPointer()) {
                System.arraycopy(curr.toByteArray(), 0, toReturn, writePos, curr.trueLength()); // need to initialzieto deeep length
                writePos += curr.trueLength();
                i++;
            } else {
                toReturn[writePos] = (byte) curr.getData();
                i++;
                writePos++;
            }
        }
        return toReturn;
    }

    public int trueLength() {
        int count = 0;
        for (Storage value : pattern) {
            if (value.isPointer()) {
                count += value.trueLength();
            } else {
                count++;
            }

        }
        return count;
    }

    public int compressedSizeInBytes() {
        int sizeOfPointer = 4;

        int count = 0; // in bytes
        for (int i = 0; i < pattern.length; i++) {
            if (pattern[i].isPointer()) {
                count += sizeOfPointer;
            } else {
                count++;
            }
        }

        if (subpatterns != null) {
            for (Storage subpattern : subpatterns) {
                count += subpattern.compressedSizeInBytes();
            }
        }

        /*for (int i = 0; i < subpatterns.size(); i++) {
            for (int j = 0; j < subpatterns.get(i).getPattern().length; j++) {
                if (subpatterns.get(i).getPattern()[j].isPointer()) {
                    count += sizeOfPointer;
                } else {
                    count++;
                }
            }

        }*/

        return count;
    }
}
